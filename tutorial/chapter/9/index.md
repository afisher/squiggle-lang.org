---
title: Examples
---

This example is for a [Reverse Polish Notation (RPN)][rpn] calculator. The
Squiggle version contains more exception throwing, which is automatically
generated by Squiggle.

If you're not familiar with RPN, here's a quick translation:

**RPN:** `2 3 4 * 3 - +`

**Normal:** `2 + ((3 * 4) - 3)`

## rpn.js

```javascript
// Note that the Squiggle version has much more
// error checking embedded in its output.

var L = require("lodash");

var text = "2 3 4 * 3 - +";

var table = {
  "+": function(a, b) { return a + b; },
  "-": function(a, b) { return a - b; },
  "*": function(a, b) { return a * b; },
  "/": function(a, b) { return a / b; }
};

function tokenize(text) {
    return text.split(" ").map(tokenValue);
}

function tokenValue(token) {
    if (table.hasOwnProperty(token)) {
        return table[token];
    } else {
        return Number(token);
    }
}

function evaluateWithStack(stack, values) {
    if (values.length === 0) {
        return stack[0];
    }
    var i = stack.length;
    var x = values[0];
    var v = values.slice(1);
    if (L.isFunction(x)) {
        var a = stack[i - 1];
        var b = stack[i - 2];
        var y = x(a, b);
        return evaluateWithStack(
            stack.slice(0, i - 2).concat([y]),
            v
        );
    } else {
        return evaluateWithStack(
            stack.concat([x]),
            v
        );
    }
}

function evaluate(text) {
    return evaluateWithStack([], tokenize(text));
}

console.log(evaluate(text));
```

## rpn.squiggle

```squiggle
let {console} = global

def foldRight(xs, z, f)
    def g(acc, x, _, _)
        f(x, acc)
    end
    xs.slice().reverse().reduce(g, z)
end

def Branch(data, left, right)
    {type: "Branch", data, left, right}
end

let Tip = {type: "Tip"}

def leaf(x)
    Branch(x, Tip, Tip)
end

let x1 = "Welcome to BST-land!"
console.log(x1)

# This actually doesn't end up looking much better with pattern matching since
# we need to make the "less-than" check on the data.
def bstAdd(n, d)
    if n.type == "Tip" then
        leaf(d)
    elseif n.type == "Branch" then
        if d < n.data then
            Branch(n.data, bstAdd(n.left, d), n.right)
        else
            Branch(n.data, n.left, bstAdd(n.right, d))
        end
    else
        error "not a node"
    end
end

def inOrder(node)
    match node
    case {type: "Tip"} then
        []
    case {type: "Branch", left, right, data} then
        inOrder(left) ++ [data] ++ inOrder(right)
    end
end

let root = foldRight(
    [4, 2, 1, 3, 6, 5, 7],
    Tip,
    fn(x, node) bstAdd(node, x)
)

console.log(inOrder(root))
```

[rpn]: https://en.wikipedia.org/wiki/Reverse_Polish_notation

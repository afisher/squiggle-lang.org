---
title: Examples
---

This example is for a [Reverse Polish Notation (RPN)][rpn] calculator. The Squiggle version contains more exception throwing, which is automatically generated by Squiggle.

If you're not familiar with RPN, here's a quick translation:

**RPN:** `2 3 4 * 3 - +`

**Normal:** `2 + ((3 * 4) - 3)`

## rpn.js

```javascript
var text = "2 3 4 * 3 - +";

var table = {
  "+": function(a, b) { return a + b; },
  "-": function(a, b) { return a - b; },
  "*": function(a, b) { return a * b; },
  "/": function(a, b) { return a / b; }
};

function tokenize(text) {
    return text.split(" ").map(tokenValue);
}

function tokenValue(token) {
    if (table.hasOwnProperty(token)) {
        return table[token];
    } else {
        return Number(token);
    }
}

function evaluateWithStack(stack, values) {
    if (values.length === 0) {
        return stack[0];
    }
    var i = stack.length;
    var x = values[0];
    var v = values.slice(1);
    if (typeof x === "function") {
        var a = stack[i - 1];
        var b = stack[i - 2];
        var y = x(a, b);
        return evaluateWithStack(
            stack.slice(0, i - 2).concat([y]),
            v
        );
    } else {
        return evaluateWithStack(
            stack.concat([x]),
            v
        );
    }
}

function evaluate(text) {
    return evaluateWithStack([], tokenize(text));
}

console.log(evaluate(text));
```

## rpn.squiggle

```squiggle
let {Number, console} = global

let text = "2 3 4 * 3 - +"

# You have to explicitly ignore arguments
# with an underscore in Squiggle.
def tokenize(text)
    text.split(" ").map(fn(x, _, _) tokenValue(x))
end

def tokenValue(token)
    match token
    case "+" then ["function", fn(a, b) a + b]
    case "-" then ["function", fn(a, b) a - b]
    case "*" then ["function", fn(a, b) a * b]
    case "/" then ["function", fn(a, b) a / b]
    case num then ["number", Number(num)]
    end
end

def evaluateWithStack(stack, values)
    match [stack, values]
    case [[first, second, ...rest], [["function", f], ...xs]] then
        evaluateWithStack([f(first, second)] ++ rest, xs)
    case [stack, [["number", n], ...xs]] then
        evaluateWithStack([n] ++ stack, xs)
    case [stack, _] then
        stack[0]
    end
end

def evaluate(text)
    evaluateWithStack([], tokenize(text))
end

console.log(evaluate(text))
```

[rpn]: https://en.wikipedia.org/wiki/Reverse_Polish_notation

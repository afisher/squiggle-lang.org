---
layout: default
title: "Tutorial :: Squiggle"
---

<div id="toc" class="toc"></div>

# Introduction

## About this tutorial

Howdy! If you're reading this, hopefully it's because you're interested in
learning the Squiggle programming language. If so, read on!

## Prerequisites

If you have never used [Node.js][] or [npm][], you should learn those first.
This tutorial assumes you have both tools installed and are familiar with the
process of installing and using npm modules.

## Getting started

Squiggle can be installed via npm:

    npm install -g saikobee/squiggle

Eventually there will be a published npm package for Squiggle, but for now you
can just install it via the GitHub shorthand. Please be aware that Squiggle
fully intends to follow [Semantic Versioning][semver], but is currently version
zero, so things may change at any point.

## What about browsers?

You may have noticed all this talk about Node.js and not a word about browser
stuff. Well, Squiggle is totally compatible with browser environments! The
preferred way of using Squiggle code in the browser is via [Browserify][], but
it's also possible without that tool. More on this in a later chapter.

# The beginning

## Hello world

If you haven't read the introduction section, I highly recommend going back and
reading it. Everything at this point assumes you've read it.

Now why don't we write our first Squiggle program? Save it in a file called
`main.squiggle`.

    console.log("Hello, world!")

Funny enough, that is also a valid JavaScript program, but bear with me. Now to compile it, run:

    squiggle main.squiggle -o main.js

Feel free to take a look at `main.js` generated by Squiggle. It's a little
large, but that's mainly because Squiggle bundles the all of its necessary
functions into the `main.js` rather than writing two separate files.

To run it, use `node` just like you normally would:

    node main.js

You should see the program write out "Hello, world!" to the console.

## Interactive mode

Using Squiggle to compile a JavaScript file is the primary use case, but it also
features an interactive mode, also known as a REPL (historical reasons). In
order to use the REPL, simply run Squiggle as follows:

    squiggle -i

Squiggle explains everything you need to know from there. It's a great way to
quickly try something on your mind, without having to save y our work.

## Language overview

Squiggle does not invent its own world separate from JavaScript, Node.js, npm,
and friends. It is meant to be used within the existing JavaScript ecosystem,
calling JavaScript code, and being called from JavaScript.

The compiler transforms Squiggle files into JavaScript files, on a per-file
basis. You can then handle these JavaScript files just like you would hand-
written ones. Bundle them, `require` them, minify them, gzip them, whatever you
want.

## Comments

Comments start with `#` and extend to the end of the line. All text within
comments is ignored by Squiggle and not passed on to the generated JavaScript
output.

## Literals

Numbers, strings, `true`, `false`, `null`, and `undefined` are all exactly
identical in Squiggle.

    100
    3.14
    "hello"
    ""
    true
    false
    null
    undefined

Currently only double-quoted string literals are supported (no 'single quotes'), and escape characters do not work (e.g. `\"`, `\n` ).

Arrays are slightly different: they are automatically wrapped in a call to
`Object.freeze`. This makes it so no elements in the array can change after it's
created. That means no `myArray.push(4)`. JavaScript arrays already have a
`.concat` method for adding elements to a copy of the array.

    []
    [1, 2, 3]
    [[], []]
    [[1, 2, 3], [[1], [2], []]]
    ["hello", "world"]

Objects are also wrapped in `Object.freeze`, though JavaScript does not provide
an easy way to add key-value pairs to a copy of an object. Squiggle will
eventually provide a convenient function for doing that. Also, Squiggle objects require quoting keys, because you can use computed values.

    {}
    {"a": "b"}
    {"hello world": "Hello, world!"}
    {"key": 400, "x": null, "y": undefined, "o": {}}
    {someStringVariable: someStringVariable}

Functions are wrapped in `Object.freeze` as well. Functions in JavaScript can
normally have properties added afterwards, but freezing them disables that.
Also, functions in Squiggle automatically have arity checking added. That means
that if you call a function with too many or too few arguments, it will throw an
error. Functions use `fn` and don't use braces or `return`.

    fn(x) x + 1
    fn(x, y) x + y
    fn() Math.floor(Math.random() * 100)

Let's take `fn(x, y) x + y` as an example and compare that with how you'd
express the same thing in JavaScript. It might look a lot like this function:

    function(x, y) { return x + y; }

But arity checking means that it's actually more like this JavaScript function:

    function(x, y) {
        if (arguments.length !== 2) {
            throw new Error("wrong number of arguments");
        }
        return x + y;
    }

JavaScript's usual relaxed rules around argument count can lead to extremely
subtle and hard to detect bugs.  It's potentially more flexible the JavaScript
way, but much more error-prone.

## Operators

The golden rule of Squiggle, and especially of operators, is "it works like how JavaScript probably should work, in my opinion."

Here are the binary operators in order, from Squiggle:

- `|>`
- `and` / `or`
- `>=` / `<=` / `<` / `>` / `=` / `!=`
- `++`
- `+` / `-`
- `*` / `/`

### Pipe operator

The pipe operator (`|>`) is like calling a function but backwards. Normally you would write `g(f(x))`, but with the pipe operator you can write `x |> f |> g`. This allows you to think left-to-right about your function pipelines.

    [1, 2, 3] |> reverse |> console::log

### Logical operators

The logical operators (`and` and `or`) work like their JavaScript counterparts
(`&&` and `||`). They short-circuit just like in JavaScript, but if they
evaluate a non-boolean value on either side, they throw an exception. That means
you can't do `x || defaultValue`. But that is an error prone construct anyway:
take for example `0 || 123`. You probably only wanted 123 if x was undefined,
not if it was 0.

    true and false # => false
    true or false # => true
    true or do {
        console.log(
            "I would be an error, " ++
            "but I don't get evaluated!"
        )
        "potato";
    } # => true

### Comparison operators

The operators `<`, `<=`, `>`, and `>=` work like JavaScript, except they throw
an error unless both values are strings or both values are numbers. It doesn't
make much sense to ask if an array or an object is less than something else, so
this helps avoid subtle bugs.

The operator `=` is a deep equality operator. It works like JavaScript `===` for
the purpose of comparising strings, numbers, `true`, `false`, `undefined`,
`null`, and functions, but differs for arrays, and objects.

For arrays, it checks to see if all elements of both arrays are equal to each
other based on the Squiggle `=` operator. It is not aware of sparse arrays.

For objects, it checks all keys returned by `Object.keys` on both objects for
equality using the Squiggle `=` operator.

As for `!=`, it's like `=` but returns the opposite value.

    [] = [] # => true
    [2] = [1 + 1] # => true
    ["abc", "xyz"] = ["abc", "xy" ++ "z"] # => true
    {"a": "b"} = {"a": "b"} # => true
    {} = Object.create(null) # => true

### Concatenation operators

The operator `++` is basically just syntax sugar for calling the `.concat`
method. As such, it works on arrays or strings, like `[1] ++ [2, 3]` or `"abc"
++ "xyz"`. It will throw an error unless the arguments are either both strings
or both arrays.

    "abc" ++ "123" # => "abc123"
    [0, 1] ++ [2, 3] # => [0, 1, 2, 3]
    [] ++ "" # => error
    1 ++ [1, 2] # => error

### Addition and subtraction operators

The operators `+` and `-` work like JavaScript except they throw an error unless
both arguments are numbers.

    1 + 2 # => 3
    10 - 1 # => 9

### Multiplication and division operators

The operators `*` and `/` work like JavaScript except they throw an error unless
both arguments are numbers.

    2 * 3 # => 6
    1 / 2 # => 0.5

## Let bindings

At this point you know enough to use Squiggle as a basic calculator, but you still don't know how to do *variables*.

Squiggle doesn't have variables in the traditional sense that variables can
*vary* over time, that is, their value can be changed. In Squiggle, the keyword
`let` introduces bindings that cannot be changed. That is why we can use `=` as
an equality operator instead of assignment, because there is only assignment
inside of `let`.

Here's an example of a `let` binding:

    let (x = 3) x + x

This evaluates to the number 6. Note this is all part of one larger expressions.
In Squiggle, it's expressions all the way down.

You can bind multiple things within a `let` also:

    let (x = 4, y = 5) x + y

This evaluates to the number 9.

Another interesting use of this is function definitions:

    let (
        inc = fn(x) x + 1,
        printPlus1 = fn(x) console.log(inc(x))
    ) printPlus1(4)

Note in this use `printPlus1` is able to see `inc` because it's part of the same
`let` binding. That code compiles to JavaScript like this:

    (function() {
        var inc = function(x) {
            return x + 1;
        };
        var printPlus1 = function(x) {
            return console.log(inc(x));
        };
        return printPlus1(4);
    }())

## Property access

Property access is written just like JavaScript. The only difference is that in
Squiggle these will throw exceptions if `property` is not an own-property of
`object`.

    object.property
    object["property"]
    let (name = "property") in object[name]

There will eventually be useful functions for dealing with optionally present
values.

## Function and method calls

Function and method calls work pretty much exactly like in JavaScript:

    foo(1, 2, 3)
    bar()
    console.log("Hello!", "world")
    document.querySelector("body .myClass")

## Method binding

In JavaScript, the implicit parameter `this` to functions is easy to mess up.
Take for example the following code which will throw an exception in most
browsers:

    console.log("this works!");
    var log = console.log;
    log("this doesn't...");

The call to `log` fails because it *forgets* the function came from `console`
--- that is, the `this` parameter is not set to `console`.

Two correct ways to solve this in JavaScript are as follows:

    var log1 = function() {
        return console.log.apply(this, arguments);
    };
    var log2 = console.log.bind(console);

These are both rather wordy, and in practice they're easy to forget or avoid due
to their clunkinesss. Squiggle offers a simple operator to solve this: `::`.

    let (safeLog = console::log) safeLog("ok!")

Currently there is no support for computed names (like `console["log"]` vs
`console.log`) with the `::` operator, but it is likely to be added eventually.

## If-expression

Squiggle has keywords `if` and `else`, but they're actually like JavaScript's
ternary operator (`p ? x : y`), with the exception that Squiggle throws an error
if the value being checked is not a boolean.

    let (x = if (true) 3 else 4) console.log(x)

This will log 3 to the console.

You can nest them just like in JavaScript:

    let (
        numberToEnglish = fn(n)
            if (n = 1) "one"
            else if (n = 2) "two"
            else if (n = 3) "three"
            else if (n = 4) "four"
            else "some other number"
    ) console.log(numberToEnglish(2))

## Do-expression

In Squiggle, everything is an expression, but sometimes you still need to call
functions purely for their side effects. For example, take this function in
JavaScript:

    function sneakyAdd(x, y) {
        console.log("add was called with", x, y);
        return x + y;
    }
    sneakyAdd(3, 4);

Given that Squiggle automatically returns the body of a function, there has to be a way to ignore a value you don't want. The keyword `do` introduces a block that returns only the last value:

    let (
        sneakyAdd = fn(x, y) do {
            console.log("add was called with", x, y);
            return x + y;
        }
    ) sneakyAdd(3, 4)

The `do` -expression is flexible and can be used anywhere in Squiggle, not just
function bodies.

    do {
        console.log("Hello");
        console.log("World");
    }

Statements within a `do` expression must be ended with a semicolon. There is no
automatic semicolon insertion, like JavaScript.

# Predefined functions

Unless otherwise stated, all predefined functions throw an error if called with
the wrong number of parameters.

## `print`

`print(x)` is equivalent to:

    do { console.log(x); x; }

## `not`

`not(true)` gives `false`.

`not(false)` gives `true`.

## `isNan`

`isNan(NaN)` gives `true`.

`isNan(n)` where `n` is a number other than `NaN` gives `false`.

## `map`

`map(f, xs)` is equivalent to:

    fn(f, xs) xs.map(fn(x, _i, _a) f(x))

## `join`

`join(separator, xs)` is equivalent to:

    xs.join(separator)

## `foldLeft`

`foldLeft(f, z, xs)` is equivalent to:

    xs.reduce(f, z)

## `fold`

`fold` is equivalent to `foldLeft`.

## `reduce`

`reduce(f, xs)` is equivalent to:

    xs.reduce(f)

## `foldRight`

`foldRight(f, z, xs)` is equivalent to:

    reverse(xs).reduce(flip(f), z)

## `reverse`

`reverse(xs)` returns an array like `xs` but with its elements in reverse order.

## `isEmpty`

`isEmpty(xs)` is equivalent to:

    xs.length = 0

## `head`

`head(xs)` is equivalent to:

    xs[0]

## `tail`

`tail(xs)` is equivalent to:

    xs.slice(1)

## `toArray`

`toArray(xs)` is equivalent to:

    [].slice.call(xs)

## `flip`

`flip(f)` is equivalent to:

    fn(a, b) f(b, a)

## `get`

`get(k, obj)` is equivalent to:

    obj[k]

## `set`

`set(k, v, obj)` is equivalent to:

    obj[k] = v

## `methodGet`

`methodGet(name, obj)` is equivalent to:

    obj[name].bind(obj)

# JavaScript interoperability

JavaScript and Squiggle are friends. Because Squiggle just compiles down to
JavaScript files, it's trivial to call Squiggle code from JavaScript, or vice-
versa. Squiggle uses all the same data as JavaScript, so you don't even have to convert anything.

## Arity problems

Squiggle functions check their arity, but many
JavaScript functions are built assuming variadic functions. For example:

    # file increment.squiggle
    export fn(x) x + 1

    // file main.js
    var increment = require("./increment");
    console.log([1, 2, 3].map(increment));

This will fail because `Array.prototype.map` actually passes *three* parameters to its callback function: *data*, *index*, and *array*. In scenarios like this, you can wrap the Squiggle function like so:

    console.log([1, 2, 3].map(function(data, _index, _array) {
        return increment(data);
    }));

## Mutability problems

Sometimes you need mutable data. Fortunately, it's still possible to create it
in Squiggle. Squiggle does not expose a syntax like `x.y = z` to assign
properties, but it does have a `set` function.

    let (
        a = global.Array(),
        o = global.Object()
    ) do {
        set(0, "hi", a);
        set("key", "value", o);
        [a, o];
    }

    # => [["hi"], {"key": "value"}]

These are the normal `Array` and `Object` functions from JavaScript, so they
return unfrozen values.

## `this` `new` problem

Squiggle does not feature the keywords `this` or `new` from JavaScript because
they cause more harm than good, and are not necessary (in general). Some
libraries require their use, however, so Squiggle has functions for dealing with
this.

If you need to supply the value of `this` to a function, you can simply use the
standard JavaScript function methods `.apply` or `.call`:

    someFn.call(myThisValue, param1, param2)
    someFn.apply(myThisValue, [param1, param2])

If you want to use the value of `this` in a function, you can wrap your function
in `method` which makes it available as the first parameter:

    let (
        setName = fn(name, obj)
            set("name", name, obj),
        person = Object.create({
            "setName": method(setName)
        })
    ) do {
        person.setName("Simone");
        console.log(person.name);
    }

## An argument about `arguments`

Variadic functions are another source of confusion and not much value in JavaScript, so those are also not allowed in Squiggle. As such, the `arguments` magic variable is useless for Squiggle functions.

Take for example this JavaScript snippet:

    [10, 10, 10, 10].map(parseInt) // => [10, NaN, 2, 3]

This happens because `parseInt` takes an optional second parameter specifying
the numeric base to parse using (rather than normal base-10 numbers), and `map`
passes the array `index` as the second parameter, which is used by `parseInt`.
Oops! It may seem gratuitous, but the Squiggle way would be having
`parseInt(string)` and `parseIntWithBase(string, number)` as separate functions.

The function `variadic` can be used to return a new function of any amount of arguments, where the arguments are passed an as a single array (real array, not array-like `arguments` object).

    let (
        numberToString = variadic(fn(args)
            if (args.length = 1) args[0].toString()
            else args[0].toString(args[1])
        )
    ) do {
        console.log(numberToString(10)); # "10"
        console.log(numberToString(10, 16)); # "a"
    }

# Goodies

## Built-in linter

Many programming languages have tools built around them called linters. Usually
these tools advise you of potential mistakes, or othwerwise ill-advised
techniques. Frequently these tools require configuration before use, and are
completely separate from the normal process of using the language.

In Squiggle, good code is paramount, so linting is built-in to the compiler, and
non-configurable. This ensures all projects using Squiggle will adhere to common
guidelines.

In addition, Squiggle is designed so that at the language level there are as few
"gotchas" as possible, reducing the amount of linting necessary.

# Use it for your own stuff

## Using with Node.js

Currently the best way to use Squiggle with Node.js is to (unfortunately)
compile the Squiggle in advance and store it in a folder and keep it in your Git
project.

I'm not generally a fan of committing generated files, but I don't think it's
possible to generate them at installation time for your package.

Here is an example compilation script in Bash:

    #!/usr/bin/env bash
    set -e
    cd src
    for f in *.squiggle; do
        name=$(basename "$f" .squiggle)
        squiggle "$f" -o "../out/$name.js"
    done

Squiggle has a keyword for creating Node.js modules: `export`

    export 1

This is equivalent to the following JavaScript:

    module.exports = 1;

So a common pattern for creating modules is:

    export let (
        a = 1,
        b = 2,
        cSecret = 3,
        dSecret = 4,
        e = 5
    ) {
        "a": a,
        "b": b,
        "e": e
    }

This is like the following JavaScript:

    var a = 1;
    var b = 2;
    var cSecret = 3;
    var dSecret = 4;
    var e = 5;

    module.exports = {
        a: a,
        b: b,
        e: e
    };

## Using in the browser

The current way is to follow the Node.js steps and then use Browserify. There
are plans to add a Browserify transform in order to simplify this process.

Additionally, if you really don't want to use Browserify to bundle, you can
avoid the need for Browserify by never using `require()` or `export` in your
code. In this case, you'll need to pull in globals manually (or the Squiggle
linter will complain), and manually export globals. See example:

    # file bar.js
    let (
        # Import foo library from global scope.
        # Simply using `foo` won't work because the Squiggle
        # linter will complain about using an
        # undeclared binding.
        foo = global.foo

        bar1 = fn() 1,
        bar2 = fn() 2,
        bar3 = fn() 3,

        api = {
            "bar1": bar1,
            "bar2": bar2,
            "bar3": bar3
        }
    ) set("bar", api, global)

# Examples

## RPN calculator

This example is for an [RPN][] calculator. The Squiggle version does not use any
predefined Squiggle functions, so it's easier to see the syntax translation.
Also, the Squiggle version contains more exception throwing, which is
automatically generated by Squiggle.

### rpn.js

    /// Consider that the JavaScript version contains far
    /// fewer assertions than the Squiggle version.
    /// Squiggle automatically asserts that a key is an own
    /// property of the object before retreiving it
    /// (e.g. x[0], foo.bar, keys must exist or it throws).
    /// Also, functions will throw unless called with the
    /// correct number of arguments.
    //// Arrays and objects created through Squiggle are
    /// also implicitly frozen,
    /// so you can't accidentally mutate them.

    var _ = require("lodash");

    var text = "2 3 4 * 3 - +";

    var table = {
      "+": function(a, b) { return a + b; },
      "-": function(a, b) { return a - b; },
      "*": function(a, b) { return a * b; },
      "/": function(a, b) { return a / b; },
    };

    function tokenize(text) {
        return text.split(" ").map(tokenValue);
    }

    function tokenValue(token) {
        if (table.hasOwnProperty(token)) {
            return table[token];
        } else {
            return Number(token);
        }
    }

    function evaluateWithStack(stack, values) {
        if (values.length === 0) {
            return stack[0];
        }
        var i = stack.length;
        var x = values[0];
        var v = values.slice(1);
        if (_.isFunction(x)) {
            var a = stack[i - 1];
            var b = stack[i - 2];
            var y = x(a, b);
            return evaluateWithStack(
                stack.slice(0, i - 2).concat([y]),
                v
            );
        } else {
            return evaluateWithStack(
                stack.concat([x]),
                v
            );
        }
    }

    function evaluate(text) {
        return evaluateWithStack([], tokenize(text));
    }

    console.log(evaluate(text));

### rpn.squiggle

    let (
        isFunction = require("lodash").isFunction,
        Number = global.Number,
        text = "2 3 4 * 3 - +",
        table = {
            "+": fn(a, b) a + b,
            "-": fn(a, b) a - b,
            "*": fn(a, b) a * b,
            "/": fn(a, b) a / b
        },
        # You have to explicitly ignore arguments
        # with an underscore in Squiggle.
        tokenize = fn(text) text
                .split(" ")
                .map(fn(x, _i, _a) tokenValue(x)),
        tokenValue = fn(token)
            if (table.hasOwnProperty(token))
                table[token]
            else
                Number(token),
        evaluateWithStack = fn(stack, values)
            if (values.length = 0)
                stack[0]
            else let (
                i = stack.length,
                x = values[0],
                v = values.slice(1)
            ) if (isFunction(x))
                let (
                    a = stack[i - 1],
                    b = stack[i - 2],
                    y = x(a, b)
                ) evaluateWithStack(
                    stack.slice(0, i - 2) ++ [y],
                    v
                )
            else
                evaluateWithStack(stack ++ [x], v),
        evaluate = fn(text)
            evaluateWithStack([], tokenize(text))
    ) console.log(evaluate(text))

<script src="{{ site.baseurl }}/toc.js"></script>

<script>
    toc(document.querySelector("#toc"));
</script>

[rpn]: https://en.wikipedia.org/wiki/Reverse_Polish_notation
[npm]: https://www.npmjs.com/
[semver]: http://semver.org/
[node.js]: https://nodejs.org/
[browserify]: http://browserify.org/

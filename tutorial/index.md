---
layout: default
title: "Tutorial :: Squiggle"
---

<div id="toc"></div>

# Introduction

## About this tutorial

Howdy! If you're reading this, hopefully it's because you're interested in
learning the Squiggle programming language. If so, read on!

## Prerequisites

If you have never used [Node.js][] or [npm][], you should learn those first.
This tutorial assumes you have both tools installed and are familiar with the
process of installing and using npm modules.

## Getting started

Squiggle can be installed via npm:

    npm install -g saikobee/squiggle

Eventually there will be a published npm package for Squiggle, but for now you
can just install it via the GitHub shorthand. Please be aware that Squiggle
fully intends to follow [Semantic Versioning][semver], but is currently version
zero, so things may change at any point.

## What about browsers?

You may have noticed all this talk about Node.js and not a word about browser
stuff. Well, Squiggle is totally compatible with browser environments! The
preferred way of using Squiggle code in the browser is via [Browserify][], but
it's also possible without that tool. More on this in a later chapter.

# The beginning

## Hello world

If you haven't read the introduction section, I highly recommend going back and
reading it. Everything at this point assumes you've read it.

Now why don't we write our first Squiggle program? Save it in a file called
`main.squiggle`.

    console.log("Hello, world!")

Funny enough, that is also a valid JavaScript program, but bear with me. Now to compile it, run:

    squiggle main.squiggle -o main.js

Feel free to take a look at `main.js` generated by Squiggle. It's a little
large, but that's mainly because Squiggle bundles the all of its necessary
functions into the `main.js` rather than writing two separate files.

To run it, use `node` just like you normally would:

    node main.js

You should see the program write out "Hello, world!" to the console.

## Interactive mode

Using Squiggle to compile a JavaScript file is the primary use case, but it also
features an interactive mode, also known as a REPL (historical reasons). In
order to use the REPL, simply run Squiggle as follows:

    squiggle -i

Squiggle explains everything you need to know from there. It's a great way to
quickly try something on your mind, without having to save y our work.

## Language overview

Squiggle does not invent its own world separate from JavaScript, Node.js, npm,
and friends. It is meant to be used within the existing JavaScript ecosystem,
calling JavaScript code, and being called from JavaScript.

The compiler transforms Squiggle files into JavaScript files, on a per-file
basis. You can then handle these JavaScript files just like you would hand-
written ones. Bundle them, `require` them, minify them, gzip them, whatever you
want.

## Literals

Numbers, strings, `true`, `false`, `null`, and `undefined` are all exactly
identical in Squiggle.

    100
    3.14
    "hello"
    ""
    true
    false
    null
    undefined

Currently only double-quoted string literals are supported (no 'single quotes'), and escape characters do not work (e.g. `\"`, `\n` ).

Arrays are slightly different: they are automatically wrapped in a call to
`Object.freeze`. This makes it so no elements in the array can change after it's
created. That means no `myArray.push(4)`. JavaScript arrays already have a
`.concat` method for adding elements to a copy of the array.

    []
    [1, 2, 3]
    [[], []]
    [[1, 2, 3], [[1], [2], []]]
    ["hello", "world"]

Objects are also wrapped in `Object.freeze`, though JavaScript does not provide
an easy way to add key-value pairs to a copy of an object. Squiggle will
eventually provide a convenient function for doing that. Also, Squiggle objects require quoting keys, because you can use computed values.

    {}
    {"a": "b"}
    {"hello world": "Hello, world!"}
    {"key": 400, "x": null, "y": undefined, "o": {}}
    {someStringVariable: someStringVariable}

Functions are wrapped in `Object.freeze` as well. Functions in JavaScript can
normally have properties added afterwards, but freezing them disables that.
Also, functions in Squiggle automatically have arity checking added. That means
that if you call a function with too many or too few arguments, it will throw an
error. Functions use `fn` and don't use braces or `return`.

    fn(x) x + 1
    fn(x, y) x + y
    fn() Math.floor(Math.random() * 100)

Let's take `fn(x, y) x + y` as an example and compare that with how you'd
express the same thing in JavaScript. It might look a lot like this function:

    function(x, y) { return x + y; }

But arity checking means that it's actually more like this JavaScript function:

    function(x, y) {
        if (arguments.length !== 2) {
            throw new Error("wrong number of arguments");
        }
        return x + y;
    }

JavaScript's usual relaxed rules around argument count can lead to extremely
subtle and hard to detect bugs.  It's potentially more flexible the JavaScript
way, but much more error-prone.

## Operators

The golden rule of Squiggle, and especially of operators, is "it works like how JavaScript probably should work, in my opinion."

Here are the binary operators in order, from Squiggle:

- `|>`
- `and` / `or`
- `>=` / `<=` / `<` / `>` / `=` / `!=`
- `++`
- `+` / `-`
- `*` / `/`

### Pipe operator

The pipe operator (`|>`) is like calling a function but backwards. Normally you would write `g(f(x))`, but with the pipe operator you can write `x |> f |> g`. This allows you to think left-to-right about your function pipelines.

### Logical operators

The logical operators (`and` and `or`) work like their JavaScript counterparts
(`&&` and `||`). They short-circuit just like in JavaScript, but if they
evaluate a non-boolean value on either side, they throw an exception. That means
you can't do `x || defaultValue`. But that is an error prone construct anyway:
take for example `0 || 123`. You probably only wanted 123 if x was undefined,
not if it was 0.

### Comparison operators

The operators `<`, `<=`, `>`, and `>=` work like JavaScript, except they throw
an error unless both values are strings or both values are numbers. It doesn't
make much sense to ask if an array or an object is less than something else, so
this helps avoid subtle bugs.

The operator `=` is a deep equality operator. It works like JavaScript `===` for
the purpose of comparising strings, numbers, `true`, `false`, `undefined`,
`null`, and functions, but differs for arrays, and objects.

For arrays, it checks to see if all elements of both arrays are equal to each
other based on the Squiggle `=` operator. It is not aware of sparse arrays.

For objects, it checks all keys returned by `Object.keys` on both objects for
equality using the Squiggle `=` operator.

As for `!=`, it's like `=` but returns the opposite value.

### Concatenation operators

The operator `++` is basically just syntax sugar for calling the `.concat`
method. As such, it works on arrays or strings, like `[1] ++ [2, 3]` or `"abc"
++ "xyz"`. It will throw an error unless the arguments are either both strings
or both arrays.

### Addition and subtraction operators

The operators `+` and `-` work like JavaScript except they throw an error unless
both arguments are numbers.

### Multiplication and division operators

The operators `*` and `/` work like JavaScript except they throw an error unless
both arguments are numbers.

# Let bindings

At this point you know enough to use Squiggle as a basic calculator, but you still don't know how to do *variables*.

Squiggle doesn't have variables in the traditional sense that variables can
*vary* over time, that is, their value can be changed. In Squiggle, the keyword
`let` introduces bindings that cannot be changed. That is why we can use `=` as
an equality operator instead of assignment, because there is only assignment
inside of `let`.

Here's an example of a `let` binding:

    let (x = 3) x + x

This evaluates to the number 6. Note this is all part of one larger expressions.
In Squiggle, it's expressions all the way down.

You can bind multiple things within a `let` also:

    let (x = 4, y = 5) x + y

This evaluates to the number 9.

Another interesting use of this is function definitions:

    let (
        inc = fn(x) x + 1,
        printPlus1 = fn(x) console.log(inc(x))
    ) printPlus1(4)

Note in this use `printPlus1` is able to see `inc` because it's part of the same
`let` binding. That code compiles to JavaScript like this:

    (function() {
        var inc = function(x) {
            return x + 1;
        };
        var printPlus1 = function(x) {
            return console.log(inc(x));
        };
        return printPlus1(4);
    }())

# Property access

Property access is written just like JavaScript. The only difference is that in
Squiggle these will throw exceptions if `property` is not an own-property of
`object`.

    object.property
    object["property"]
    let (name = "property") in object[name]

There will eventually be useful functions for dealing with optionally present
values.

# Function and method calls

Function and method calls work pretty much exactly like in JavaScript:

    foo(1, 2, 3)
    bar()
    console.log("Hello!", "world")
    document.querySelector("body .myClass")

# Method binding

In JavaScript, the implicit parameter `this` to functions is easy to mess up.
Take for example the following code which will throw an exception in most
browsers:

    console.log("this works!");
    var log = console.log;
    log("this doesn't...");

The call to `log` fails because it *forgets* the function came from `console`
--- that is, the `this` parameter is not set to `console`.

Two correct ways to solve this in JavaScript are as follows:

    var log1 = function() {
        return console.log.apply(this, arguments);
    };
    var log2 = console.log.bind(console);

These are both rather wordy, and in practice they're easy to forget or avoid due
to their clunkinesss. Squiggle offers a simple operator to solve this: `::`.

    let (safeLog = console::log) safeLog("ok!")

Currently there is no support for computed names (like `console["log"]` vs
`console.log`) with the `::` operator, but it is likely to be added eventually.

# If-expression

Squiggle has keywords `if` and `else`, but they're actually like JavaScript's
ternary operator (`p ? x : y`), with the exception that Squiggle throws an error
if the value being checked is not a boolean.

    let (x = if (true) 3 else 4) console.log(x)

This will log 3 to the console.

You can nest them just like in JavaScript:

    let (
        numberToEnglish = fn(n)
            if (n = 1) "one"
            else if (n = 2) "two"
            else if (n = 3) "three"
            else if (n = 4) "four"
            else "some other number"
    ) console.log(numberToEnglish(2))

<script src="{{ site.baseurl }}/toc.js"></script>

<script>
    toc(document.querySelector("#toc"));
</script>

[npm]: https://www.npmjs.com/
[semver]: http://semver.org/
[node.js]: https://nodejs.org/
[browserify]: http://browserify.org/
